// tslint:disable
/**
 * おおまか家計簿 API
 * Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnnualChange
 */
export interface AnnualChange {
    /**
     * 
     * @type {string}
     * @memberof AnnualChange
     */
    month: string;
    /**
     * 
     * @type {number}
     * @memberof AnnualChange
     */
    sum_money: number;
}
/**
 * カレンダー情報
 * @export
 * @interface Calendar
 */
export interface Calendar {
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof Calendar
     */
    sum_month_money: number;
    /**
     * 
     * @type {Array<SumDateMoney>}
     * @memberof Calendar
     */
    sum_date_money: Array<SumDateMoney>;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    category_name: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    color_type: number;
}
/**
 * 日別の支出金額一覧
 * @export
 * @interface Detail
 */
export interface Detail {
    /**
     * 
     * @type {number}
     * @memberof Detail
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Detail
     */
    money: number;
    /**
     * 
     * @type {string}
     * @memberof Detail
     */
    img_file: string;
    /**
     * 
     * @type {number}
     * @memberof Detail
     */
    category_id: number;
    /**
     * 
     * @type {string}
     * @memberof Detail
     */
    category_name: string;
}
/**
 * エラーレスポンス
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<ModelError>}
     * @memberof ErrorResponse
     */
    errors: Array<ModelError>;
}
/**
 * エラー
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * エラーメッセージ
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 * 
 * @export
 * @interface MonthRate
 */
export interface MonthRate {
    /**
     * 
     * @type {number}
     * @memberof MonthRate
     */
    category_id: number;
    /**
     * 
     * @type {string}
     * @memberof MonthRate
     */
    category_name: string;
    /**
     * 
     * @type {number}
     * @memberof MonthRate
     */
    color_type: number;
    /**
     * 
     * @type {number}
     * @memberof MonthRate
     */
    money: number;
}
/**
 * 
 * @export
 * @interface Partner
 */
export interface Partner {
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    email: string;
}
/**
 * カテゴリ情報のリクエストデータ
 * @export
 * @interface RequestCategory
 */
export interface RequestCategory {
    /**
     * 
     * @type {string}
     * @memberof RequestCategory
     */
    category_name: string;
    /**
     * 
     * @type {number}
     * @memberof RequestCategory
     */
    color_type: number;
}
/**
 * パスワード変更のリクエストデータ
 * @export
 * @interface RequestChangePassword
 */
export interface RequestChangePassword {
    /**
     * 
     * @type {string}
     * @memberof RequestChangePassword
     */
    password: string;
}
/**
 * 金額情報のリクエストデータ
 * @export
 * @interface RequestDetail
 */
export interface RequestDetail {
    /**
     * 
     * @type {number}
     * @memberof RequestDetail
     */
    category_id: number;
    /**
     * 
     * @type {number}
     * @memberof RequestDetail
     */
    money: number;
    /**
     * 
     * @type {string}
     * @memberof RequestDetail
     */
    img_file: string;
    /**
     * 
     * @type {string}
     * @memberof RequestDetail
     */
    date: string;
}
/**
 * ログイン時のリクエストデータ
 * @export
 * @interface RequestLogin
 */
export interface RequestLogin {
    /**
     * 
     * @type {string}
     * @memberof RequestLogin
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof RequestLogin
     */
    password: string;
}
/**
 * パートナーユーザー情報のリクエストデータ
 * @export
 * @interface RequestPartner
 */
export interface RequestPartner {
    /**
     * 
     * @type {number}
     * @memberof RequestPartner
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RequestPartner
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RequestPartner
     */
    email: string;
}
/**
 * 会員登録時のリクエストデータ
 * @export
 * @interface RequestRegister
 */
export interface RequestRegister {
    /**
     * 
     * @type {string}
     * @memberof RequestRegister
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRegister
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRegister
     */
    password: string;
}
/**
 * パスワードリマインド(キー送信)のリクエストデータ
 * @export
 * @interface RequestRemindKey
 */
export interface RequestRemindKey {
    /**
     * 
     * @type {string}
     * @memberof RequestRemindKey
     */
    auth_key: string;
}
/**
 * パスワードリマインド(アドレス送信)のリクエストデータ
 * @export
 * @interface RequestRemindMail
 */
export interface RequestRemindMail {
    /**
     * 
     * @type {string}
     * @memberof RequestRemindMail
     */
    email: string;
}
/**
 * 日別の支出金額の合計
 * @export
 * @interface SumDateMoney
 */
export interface SumDateMoney {
    /**
     * 
     * @type {string}
     * @memberof SumDateMoney
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof SumDateMoney
     */
    money: number;
}
/**
 * ユーザー情報
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    user_type: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    main_user_id: number;
}

/**
 * AnnualChangeApi - axios parameter creator
 * @export
 */
export const AnnualChangeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 年間の支出推移
         * @summary No.20 年間の支出推移取得
         * @param {string} date 現在日付
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualChange: async (date: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling getAnnualChange.');
            }
            const localVarPath = `/annual_change/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnualChangeApi - functional programming interface
 * @export
 */
export const AnnualChangeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 年間の支出推移
         * @summary No.20 年間の支出推移取得
         * @param {string} date 現在日付
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnualChange(date: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnualChange>>> {
            const localVarAxiosArgs = await AnnualChangeApiAxiosParamCreator(configuration).getAnnualChange(date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnnualChangeApi - factory interface
 * @export
 */
export const AnnualChangeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 年間の支出推移
         * @summary No.20 年間の支出推移取得
         * @param {string} date 現在日付
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualChange(date: string, options?: any): AxiosPromise<Array<AnnualChange>> {
            return AnnualChangeApiFp(configuration).getAnnualChange(date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnualChangeApi - object-oriented interface
 * @export
 * @class AnnualChangeApi
 * @extends {BaseAPI}
 */
export class AnnualChangeApi extends BaseAPI {
    /**
     * 年間の支出推移
     * @summary No.20 年間の支出推移取得
     * @param {string} date 現在日付
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnualChangeApi
     */
    public getAnnualChange(date: string, options?: any) {
        return AnnualChangeApiFp(this.configuration).getAnnualChange(date, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * カレンダー情報取得
         * @summary No.10 カレンダー情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalender: async (date: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling getCalender.');
            }
            const localVarPath = `/calendar/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    return {
        /**
         * カレンダー情報取得
         * @summary No.10 カレンダー情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalender(date: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Calendar>> {
            const localVarAxiosArgs = await CalendarApiAxiosParamCreator(configuration).getCalender(date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * カレンダー情報取得
         * @summary No.10 カレンダー情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalender(date: string, options?: any): AxiosPromise<Calendar> {
            return CalendarApiFp(configuration).getCalender(date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * カレンダー情報取得
     * @summary No.10 カレンダー情報取得
     * @param {string} date date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalender(date: string, options?: any) {
        return CalendarApiFp(this.configuration).getCalender(date, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * カテゴリ新規登録
         * @summary No.16 カテゴリ新規登録
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory: async (requestCategory: RequestCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestCategory' is not null or undefined
            if (requestCategory === null || requestCategory === undefined) {
                throw new RequiredError('requestCategory','Required parameter requestCategory was null or undefined when calling addCategory.');
            }
            const localVarPath = `/category/create`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestCategory !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestCategory !== undefined ? requestCategory : {}) : (requestCategory || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * カテゴリ情報削除
         * @summary No.18 カテゴリ情報削除
         * @param {number} categoryId カテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/category/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * カテゴリ情報編集
         * @summary No.17 カテゴリ情報編集
         * @param {number} categoryId カテゴリID
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCategory: async (categoryId: number, requestCategory: RequestCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling editCategory.');
            }
            // verify required parameter 'requestCategory' is not null or undefined
            if (requestCategory === null || requestCategory === undefined) {
                throw new RequiredError('requestCategory','Required parameter requestCategory was null or undefined when calling editCategory.');
            }
            const localVarPath = `/category/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestCategory !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestCategory !== undefined ? requestCategory : {}) : (requestCategory || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * カテゴリ情報取得
         * @summary No.15 カテゴリ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * カテゴリ新規登録
         * @summary No.16 カテゴリ新規登録
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCategory(requestCategory: RequestCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoryApiAxiosParamCreator(configuration).addCategory(requestCategory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * カテゴリ情報削除
         * @summary No.18 カテゴリ情報削除
         * @param {number} categoryId カテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CategoryApiAxiosParamCreator(configuration).deleteCategory(categoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * カテゴリ情報編集
         * @summary No.17 カテゴリ情報編集
         * @param {number} categoryId カテゴリID
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCategory(categoryId: number, requestCategory: RequestCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoryApiAxiosParamCreator(configuration).editCategory(categoryId, requestCategory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * カテゴリ情報取得
         * @summary No.15 カテゴリ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await CategoryApiAxiosParamCreator(configuration).getCategories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * カテゴリ新規登録
         * @summary No.16 カテゴリ新規登録
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(requestCategory: RequestCategory, options?: any): AxiosPromise<Category> {
            return CategoryApiFp(configuration).addCategory(requestCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * カテゴリ情報削除
         * @summary No.18 カテゴリ情報削除
         * @param {number} categoryId カテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options?: any): AxiosPromise<void> {
            return CategoryApiFp(configuration).deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * カテゴリ情報編集
         * @summary No.17 カテゴリ情報編集
         * @param {number} categoryId カテゴリID
         * @param {RequestCategory} requestCategory リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCategory(categoryId: number, requestCategory: RequestCategory, options?: any): AxiosPromise<Category> {
            return CategoryApiFp(configuration).editCategory(categoryId, requestCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * カテゴリ情報取得
         * @summary No.15 カテゴリ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any): AxiosPromise<Array<Category>> {
            return CategoryApiFp(configuration).getCategories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * カテゴリ新規登録
     * @summary No.16 カテゴリ新規登録
     * @param {RequestCategory} requestCategory リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public addCategory(requestCategory: RequestCategory, options?: any) {
        return CategoryApiFp(this.configuration).addCategory(requestCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * カテゴリ情報削除
     * @summary No.18 カテゴリ情報削除
     * @param {number} categoryId カテゴリID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public deleteCategory(categoryId: number, options?: any) {
        return CategoryApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * カテゴリ情報編集
     * @summary No.17 カテゴリ情報編集
     * @param {number} categoryId カテゴリID
     * @param {RequestCategory} requestCategory リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public editCategory(categoryId: number, requestCategory: RequestCategory, options?: any) {
        return CategoryApiFp(this.configuration).editCategory(categoryId, requestCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * カテゴリ情報取得
     * @summary No.15 カテゴリ情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategories(options?: any) {
        return CategoryApiFp(this.configuration).getCategories(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DetailApi - axios parameter creator
 * @export
 */
export const DetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 金額入力
         * @summary No.12 金額情報新規登録
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDetail: async (requestDetail: RequestDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestDetail' is not null or undefined
            if (requestDetail === null || requestDetail === undefined) {
                throw new RequiredError('requestDetail','Required parameter requestDetail was null or undefined when calling addDetail.');
            }
            const localVarPath = `/detail/create`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestDetail !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestDetail !== undefined ? requestDetail : {}) : (requestDetail || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 金額削除
         * @summary No.14 金額情報削除
         * @param {number} moneyId money_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDetail: async (moneyId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'moneyId' is not null or undefined
            if (moneyId === null || moneyId === undefined) {
                throw new RequiredError('moneyId','Required parameter moneyId was null or undefined when calling deleteDetail.');
            }
            const localVarPath = `/detail/{money_id}`
                .replace(`{${"money_id"}}`, encodeURIComponent(String(moneyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 金額編集
         * @summary No.13 金額情報編集
         * @param {number} moneyId money_id
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDetail: async (moneyId: number, requestDetail: RequestDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'moneyId' is not null or undefined
            if (moneyId === null || moneyId === undefined) {
                throw new RequiredError('moneyId','Required parameter moneyId was null or undefined when calling editDetail.');
            }
            // verify required parameter 'requestDetail' is not null or undefined
            if (requestDetail === null || requestDetail === undefined) {
                throw new RequiredError('requestDetail','Required parameter requestDetail was null or undefined when calling editDetail.');
            }
            const localVarPath = `/detail/{money_id}`
                .replace(`{${"money_id"}}`, encodeURIComponent(String(moneyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestDetail !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestDetail !== undefined ? requestDetail : {}) : (requestDetail || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 日別の金額情報取得
         * @summary No.11 日別の金額情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: async (date: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling getDetails.');
            }
            const localVarPath = `/detail/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailApi - functional programming interface
 * @export
 */
export const DetailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 金額入力
         * @summary No.12 金額情報新規登録
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDetail(requestDetail: RequestDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detail>> {
            const localVarAxiosArgs = await DetailApiAxiosParamCreator(configuration).addDetail(requestDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 金額削除
         * @summary No.14 金額情報削除
         * @param {number} moneyId money_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDetail(moneyId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DetailApiAxiosParamCreator(configuration).deleteDetail(moneyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 金額編集
         * @summary No.13 金額情報編集
         * @param {number} moneyId money_id
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDetail(moneyId: number, requestDetail: RequestDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detail>> {
            const localVarAxiosArgs = await DetailApiAxiosParamCreator(configuration).editDetail(moneyId, requestDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 日別の金額情報取得
         * @summary No.11 日別の金額情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetails(date: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Detail>>> {
            const localVarAxiosArgs = await DetailApiAxiosParamCreator(configuration).getDetails(date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DetailApi - factory interface
 * @export
 */
export const DetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 金額入力
         * @summary No.12 金額情報新規登録
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDetail(requestDetail: RequestDetail, options?: any): AxiosPromise<Detail> {
            return DetailApiFp(configuration).addDetail(requestDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 金額削除
         * @summary No.14 金額情報削除
         * @param {number} moneyId money_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDetail(moneyId: number, options?: any): AxiosPromise<void> {
            return DetailApiFp(configuration).deleteDetail(moneyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 金額編集
         * @summary No.13 金額情報編集
         * @param {number} moneyId money_id
         * @param {RequestDetail} requestDetail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDetail(moneyId: number, requestDetail: RequestDetail, options?: any): AxiosPromise<Detail> {
            return DetailApiFp(configuration).editDetail(moneyId, requestDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 日別の金額情報取得
         * @summary No.11 日別の金額情報取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(date: string, options?: any): AxiosPromise<Array<Detail>> {
            return DetailApiFp(configuration).getDetails(date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailApi - object-oriented interface
 * @export
 * @class DetailApi
 * @extends {BaseAPI}
 */
export class DetailApi extends BaseAPI {
    /**
     * 金額入力
     * @summary No.12 金額情報新規登録
     * @param {RequestDetail} requestDetail リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public addDetail(requestDetail: RequestDetail, options?: any) {
        return DetailApiFp(this.configuration).addDetail(requestDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 金額削除
     * @summary No.14 金額情報削除
     * @param {number} moneyId money_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public deleteDetail(moneyId: number, options?: any) {
        return DetailApiFp(this.configuration).deleteDetail(moneyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 金額編集
     * @summary No.13 金額情報編集
     * @param {number} moneyId money_id
     * @param {RequestDetail} requestDetail リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public editDetail(moneyId: number, requestDetail: RequestDetail, options?: any) {
        return DetailApiFp(this.configuration).editDetail(moneyId, requestDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 日別の金額情報取得
     * @summary No.11 日別の金額情報取得
     * @param {string} date date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public getDetails(date: string, options?: any) {
        return DetailApiFp(this.configuration).getDetails(date, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MonthRateApi - axios parameter creator
 * @export
 */
export const MonthRateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 月のカテゴリ別支出金額取得
         * @summary No.19 月のカテゴリ別支出金額取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonthRate: async (date: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling getMonthRate.');
            }
            const localVarPath = `/month-rate/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthRateApi - functional programming interface
 * @export
 */
export const MonthRateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 月のカテゴリ別支出金額取得
         * @summary No.19 月のカテゴリ別支出金額取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonthRate(date: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MonthRate>>> {
            const localVarAxiosArgs = await MonthRateApiAxiosParamCreator(configuration).getMonthRate(date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MonthRateApi - factory interface
 * @export
 */
export const MonthRateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 月のカテゴリ別支出金額取得
         * @summary No.19 月のカテゴリ別支出金額取得
         * @param {string} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonthRate(date: string, options?: any): AxiosPromise<Array<MonthRate>> {
            return MonthRateApiFp(configuration).getMonthRate(date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonthRateApi - object-oriented interface
 * @export
 * @class MonthRateApi
 * @extends {BaseAPI}
 */
export class MonthRateApi extends BaseAPI {
    /**
     * 月のカテゴリ別支出金額取得
     * @summary No.19 月のカテゴリ別支出金額取得
     * @param {string} date date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthRateApi
     */
    public getMonthRate(date: string, options?: any) {
        return MonthRateApiFp(this.configuration).getMonthRate(date, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * パートナーユーザー登録
         * @summary No.22 パートナーユーザー登録
         * @param {RequestPartner} requestPartner リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartner: async (requestPartner: RequestPartner, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestPartner' is not null or undefined
            if (requestPartner === null || requestPartner === undefined) {
                throw new RequiredError('requestPartner','Required parameter requestPartner was null or undefined when calling addPartner.');
            }
            const localVarPath = `/partner/create`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestPartner !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestPartner !== undefined ? requestPartner : {}) : (requestPartner || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パートナーユーザー削除
         * @summary No.23 パートナーユーザー削除
         * @param {number} userId パートナーユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartner: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deletePartner.');
            }
            const localVarPath = `/partner/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パートナーユーザー取得
         * @summary No.21 パートナーユーザー取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * パートナーユーザー登録
         * @summary No.22 パートナーユーザー登録
         * @param {RequestPartner} requestPartner リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPartner(requestPartner: RequestPartner, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner>> {
            const localVarAxiosArgs = await PartnerApiAxiosParamCreator(configuration).addPartner(requestPartner, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パートナーユーザー削除
         * @summary No.23 パートナーユーザー削除
         * @param {number} userId パートナーユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePartner(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PartnerApiAxiosParamCreator(configuration).deletePartner(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パートナーユーザー取得
         * @summary No.21 パートナーユーザー取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartners(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Partner>>> {
            const localVarAxiosArgs = await PartnerApiAxiosParamCreator(configuration).getPartners(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * パートナーユーザー登録
         * @summary No.22 パートナーユーザー登録
         * @param {RequestPartner} requestPartner リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartner(requestPartner: RequestPartner, options?: any): AxiosPromise<Partner> {
            return PartnerApiFp(configuration).addPartner(requestPartner, options).then((request) => request(axios, basePath));
        },
        /**
         * パートナーユーザー削除
         * @summary No.23 パートナーユーザー削除
         * @param {number} userId パートナーユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartner(userId: number, options?: any): AxiosPromise<void> {
            return PartnerApiFp(configuration).deletePartner(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * パートナーユーザー取得
         * @summary No.21 パートナーユーザー取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners(options?: any): AxiosPromise<Array<Partner>> {
            return PartnerApiFp(configuration).getPartners(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * パートナーユーザー登録
     * @summary No.22 パートナーユーザー登録
     * @param {RequestPartner} requestPartner リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public addPartner(requestPartner: RequestPartner, options?: any) {
        return PartnerApiFp(this.configuration).addPartner(requestPartner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パートナーユーザー削除
     * @summary No.23 パートナーユーザー削除
     * @param {number} userId パートナーユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public deletePartner(userId: number, options?: any) {
        return PartnerApiFp(this.configuration).deletePartner(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パートナーユーザー取得
     * @summary No.21 パートナーユーザー取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartners(options?: any) {
        return PartnerApiFp(this.configuration).getPartners(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 認証ルーティング
         * @summary No.5 認証ルーティング
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRooting: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワード変更処理
         * @summary No.9 パスワード変更
         * @param {RequestChangePassword} requestChangePassword リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (requestChangePassword: RequestChangePassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestChangePassword' is not null or undefined
            if (requestChangePassword === null || requestChangePassword === undefined) {
                throw new RequiredError('requestChangePassword','Required parameter requestChangePassword was null or undefined when calling changePassword.');
            }
            const localVarPath = `/change-password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestChangePassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestChangePassword !== undefined ? requestChangePassword : {}) : (requestChangePassword || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン処理
         * @summary No.1 ログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (requestLogin: RequestLogin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestLogin' is not null or undefined
            if (requestLogin === null || requestLogin === undefined) {
                throw new RequiredError('requestLogin','Required parameter requestLogin was null or undefined when calling login.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestLogin !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestLogin !== undefined ? requestLogin : {}) : (requestLogin || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログアウト処理
         * @summary No.6 ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パートナーユーザーによるログイン処理
         * @summary No.3 パートナーログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerLogin: async (requestLogin: RequestLogin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestLogin' is not null or undefined
            if (requestLogin === null || requestLogin === undefined) {
                throw new RequiredError('requestLogin','Required parameter requestLogin was null or undefined when calling partnerLogin.');
            }
            const localVarPath = `/partner-login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestLogin !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestLogin !== undefined ? requestLogin : {}) : (requestLogin || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 会員登録処理
         * @summary No.2 会員登録
         * @param {RequestRegister} requestRegister リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (requestRegister: RequestRegister, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestRegister' is not null or undefined
            if (requestRegister === null || requestRegister === undefined) {
                throw new RequiredError('requestRegister','Required parameter requestRegister was null or undefined when calling register.');
            }
            const localVarPath = `/register`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestRegister !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestRegister !== undefined ? requestRegister : {}) : (requestRegister || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワードリマインド アドレス送信
         * @summary No.7 パスワードリマインド(アドレス送信)
         * @param {RequestRemindMail} requestRemindMail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remindEmail: async (requestRemindMail: RequestRemindMail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestRemindMail' is not null or undefined
            if (requestRemindMail === null || requestRemindMail === undefined) {
                throw new RequiredError('requestRemindMail','Required parameter requestRemindMail was null or undefined when calling remindEmail.');
            }
            const localVarPath = `/remind-mail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestRemindMail !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestRemindMail !== undefined ? requestRemindMail : {}) : (requestRemindMail || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワードリマインド キー送信
         * @summary No.8 パスワードリマインド(キー送信)
         * @param {RequestRemindKey} requestRemindKey リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remindKey: async (requestRemindKey: RequestRemindKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestRemindKey' is not null or undefined
            if (requestRemindKey === null || requestRemindKey === undefined) {
                throw new RequiredError('requestRemindKey','Required parameter requestRemindKey was null or undefined when calling remindKey.');
            }
            const localVarPath = `/remind-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestRemindKey !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestRemindKey !== undefined ? requestRemindKey : {}) : (requestRemindKey || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お試しユーザーによるログイン処理
         * @summary No.4 お試しログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryLogin: async (requestLogin: RequestLogin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestLogin' is not null or undefined
            if (requestLogin === null || requestLogin === undefined) {
                throw new RequiredError('requestLogin','Required parameter requestLogin was null or undefined when calling tryLogin.');
            }
            const localVarPath = `/trial-login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestLogin !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestLogin !== undefined ? requestLogin : {}) : (requestLogin || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 認証ルーティング
         * @summary No.5 認証ルーティング
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRooting(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).authRooting(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パスワード変更処理
         * @summary No.9 パスワード変更
         * @param {RequestChangePassword} requestChangePassword リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(requestChangePassword: RequestChangePassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).changePassword(requestChangePassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログイン処理
         * @summary No.1 ログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(requestLogin: RequestLogin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).login(requestLogin, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログアウト処理
         * @summary No.6 ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).logout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パートナーユーザーによるログイン処理
         * @summary No.3 パートナーログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerLogin(requestLogin: RequestLogin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).partnerLogin(requestLogin, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 会員登録処理
         * @summary No.2 会員登録
         * @param {RequestRegister} requestRegister リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(requestRegister: RequestRegister, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).register(requestRegister, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パスワードリマインド アドレス送信
         * @summary No.7 パスワードリマインド(アドレス送信)
         * @param {RequestRemindMail} requestRemindMail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remindEmail(requestRemindMail: RequestRemindMail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).remindEmail(requestRemindMail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パスワードリマインド キー送信
         * @summary No.8 パスワードリマインド(キー送信)
         * @param {RequestRemindKey} requestRemindKey リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remindKey(requestRemindKey: RequestRemindKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).remindKey(requestRemindKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * お試しユーザーによるログイン処理
         * @summary No.4 お試しログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryLogin(requestLogin: RequestLogin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).tryLogin(requestLogin, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 認証ルーティング
         * @summary No.5 認証ルーティング
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRooting(options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).authRooting(options).then((request) => request(axios, basePath));
        },
        /**
         * パスワード変更処理
         * @summary No.9 パスワード変更
         * @param {RequestChangePassword} requestChangePassword リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestChangePassword: RequestChangePassword, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).changePassword(requestChangePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン処理
         * @summary No.1 ログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestLogin: RequestLogin, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).login(requestLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * ログアウト処理
         * @summary No.6 ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).logout(options).then((request) => request(axios, basePath));
        },
        /**
         * パートナーユーザーによるログイン処理
         * @summary No.3 パートナーログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerLogin(requestLogin: RequestLogin, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).partnerLogin(requestLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * 会員登録処理
         * @summary No.2 会員登録
         * @param {RequestRegister} requestRegister リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestRegister: RequestRegister, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).register(requestRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワードリマインド アドレス送信
         * @summary No.7 パスワードリマインド(アドレス送信)
         * @param {RequestRemindMail} requestRemindMail リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remindEmail(requestRemindMail: RequestRemindMail, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).remindEmail(requestRemindMail, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワードリマインド キー送信
         * @summary No.8 パスワードリマインド(キー送信)
         * @param {RequestRemindKey} requestRemindKey リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remindKey(requestRemindKey: RequestRemindKey, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).remindKey(requestRemindKey, options).then((request) => request(axios, basePath));
        },
        /**
         * お試しユーザーによるログイン処理
         * @summary No.4 お試しログイン
         * @param {RequestLogin} requestLogin リクエストパラメータ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryLogin(requestLogin: RequestLogin, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).tryLogin(requestLogin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 認証ルーティング
     * @summary No.5 認証ルーティング
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authRooting(options?: any) {
        return UsersApiFp(this.configuration).authRooting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワード変更処理
     * @summary No.9 パスワード変更
     * @param {RequestChangePassword} requestChangePassword リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePassword(requestChangePassword: RequestChangePassword, options?: any) {
        return UsersApiFp(this.configuration).changePassword(requestChangePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン処理
     * @summary No.1 ログイン
     * @param {RequestLogin} requestLogin リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(requestLogin: RequestLogin, options?: any) {
        return UsersApiFp(this.configuration).login(requestLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログアウト処理
     * @summary No.6 ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logout(options?: any) {
        return UsersApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パートナーユーザーによるログイン処理
     * @summary No.3 パートナーログイン
     * @param {RequestLogin} requestLogin リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public partnerLogin(requestLogin: RequestLogin, options?: any) {
        return UsersApiFp(this.configuration).partnerLogin(requestLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 会員登録処理
     * @summary No.2 会員登録
     * @param {RequestRegister} requestRegister リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public register(requestRegister: RequestRegister, options?: any) {
        return UsersApiFp(this.configuration).register(requestRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワードリマインド アドレス送信
     * @summary No.7 パスワードリマインド(アドレス送信)
     * @param {RequestRemindMail} requestRemindMail リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public remindEmail(requestRemindMail: RequestRemindMail, options?: any) {
        return UsersApiFp(this.configuration).remindEmail(requestRemindMail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワードリマインド キー送信
     * @summary No.8 パスワードリマインド(キー送信)
     * @param {RequestRemindKey} requestRemindKey リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public remindKey(requestRemindKey: RequestRemindKey, options?: any) {
        return UsersApiFp(this.configuration).remindKey(requestRemindKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * お試しユーザーによるログイン処理
     * @summary No.4 お試しログイン
     * @param {RequestLogin} requestLogin リクエストパラメータ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tryLogin(requestLogin: RequestLogin, options?: any) {
        return UsersApiFp(this.configuration).tryLogin(requestLogin, options).then((request) => request(this.axios, this.basePath));
    }

}


